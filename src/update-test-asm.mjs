import child_process from "node:child_process";
import fs from "node:fs";
import os from "node:os";
import path from "node:path";
import { isModuleNodeMain } from "./is-main.mjs";

export async function assembleTestASMsAsync(source, outASMs = new Map()) {
  let asmDirectiveRE = /\bASM_X86_64\((?<body>(?:"[^\n]*"|\s)*?)\)/g;
  let lineRE = /"(?<line>[^\n]*)"/g;
  for (let directiveMatch of source.matchAll(asmDirectiveRE)) {
    let assemblyLines = [];
    for (let lineMatch of directiveMatch.groups.body.matchAll(lineRE)) {
      assemblyLines.push(lineMatch.groups.line);
    }
    let instructionsBytes = await assembleAsync(assemblyLines, {
      arch: "x86_64",
    });
    outASMs.set(assemblyLines.join(""), instructionsBytes);
  }
  return outASMs;
}

function makeCxxNumberLiterals(numbers) {
  return numbers
    .map((n) => `0x${n.toString(16).padStart(2, "0")}, `)
    .join("")
    .trim();
}

export async function assembleAsync(assemblyLines, { arch }) {
  console.assert(arch === "x86_64", "only x86_64 is supported right now");
  let code = ".code64\n" + assemblyLines.join("\n") + "\n";

  let tempDir = await fs.promises.mkdtemp(
    path.join(os.tmpdir(), "cppstacksize-update-test-asm-")
  );
  try {
    let binaryFilePath = path.join(tempDir, "output.bin");
    await new Promise((resolve, reject) => {
      let childProcess = child_process.execFile(
        "yasm",
        ["-p", "gas", "-L", "nasm", "-o", binaryFilePath, "-"],
        {
          windowsHide: true,
        },
        (err, stdout, stderr) => {
          if (err !== null) {
            reject(err);
            return;
          }
          resolve(stdout);
        }
      );
      childProcess.stdin.write(code);
      childProcess.stdin.end();
    });
    let bytesBuffer = await fs.promises.readFile(binaryFilePath);
    return [...bytesBuffer];
  } finally {
    await fs.promises.rm(tempDir, { recursive: true });
  }
}

function getYASMListingAsync(code) {
  return new Promise((resolve, reject) => {
    // HACK(strager): /dev/stdout does not work by default because Node.js's
    // 'pipe' option actually creates a UNIX socketpair, not a UNIX pipe. Give
    // yasm a UNIX pipe as stdout by piping to the 'cat' command.
    // HACK(strager): Because we pipe to 'cat', the shell will prefer 'cat''s
    // exit code and discard 'yasm''s exit code. To prevent this, use Bash's
    // 'pipefail' setting.
    let childProcess = child_process.exec(
      "set -o pipefail; yasm -p gas -L nasm -l /dev/stdout -o /dev/null - | cat",
      {
        shell: "/bin/bash",
        windowsHide: true,
      },
      (err, stdout, stderr) => {
        if (err !== null) {
          reject(err);
          return;
        }
        resolve(stdout);
      }
    );
    childProcess.stdin.write(code);
    childProcess.stdin.end();
  });
}

function hexStringToByteArray(hexes) {
  let outBytes = [];
  for (let i = 0; i < hexes.length; i += 2) {
    outBytes.push(parseInt(hexes.substr(i, 2), 16));
  }
  return outBytes;
}

async function mainAsync() {
  let outFile = process.argv[2];
  let files = process.argv.slice(3);
  if (files.length === 0) {
    console.error(
      `usage: ${process.argv[0]} ${process.argv[1]} test/test-asm-generated.cpp file.cpp [file.cpp ...]`
    );
    process.exit(2);
  }
  let asms = new Map();
  for (let file of files) {
    let source = fs.readFileSync(file, "utf-8");
    await assembleTestASMsAsync(source, asms);
  }
  let asmEntries = [...asms.entries()].sort(
    ([aAssembly, _aBytes], [bAssembly, _bBytes]) => {
      if (aAssembly < bAssembly) return -1;
      if (aAssembly > bAssembly) return +1;
      return 0;
    }
  );

  let outLines = [];
  outLines.push("// This file was GENERATED by update-test-asm.mjs.");
  outLines.push("// DO NOT MODIFY BY HAND");
  outLines.push("");
  outLines.push("#include <cppstacksize/asm.h>");
  outLines.push("#include <cppstacksize/base.h>");
  outLines.push("#include <cstdio>");
  outLines.push("#include <exception>");
  outLines.push("#include <span>");
  outLines.push("#include <string_view>");
  outLines.push("#include <unordered_map>");
  outLines.push("");
  outLines.push("namespace cppstacksize {");
  outLines.push("namespace {");
  outLines.push("// clang-format off");
  for (let [i, [_assembly, bytes]] of asmEntries.entries()) {
    outLines.push(
      `constexpr U8 listing_${i}[] = {${makeCxxNumberLiterals(bytes)}};`
    );
  }
  outLines.push("");
  outLines.push(
    "std::unordered_map<std::string_view, std::span<const U8>> asm_listings = {"
  );
  for (let [i, [assembly, _bytes]] of asmEntries.entries()) {
    outLines.push(`    {"${assembly}", std::span<const U8>(listing_${i})},`);
  }
  outLines.push("};");
  outLines.push("// clang-format on");
  outLines.push("}");
  outLines.push("");
  outLines.push("std::span<const U8> assemble_x86_64(const char* assembly) {");
  outLines.push("  auto it = asm_listings.find(assembly);");
  outLines.push("  if (it == asm_listings.end()) {");
  outLines.push(
    '    std::fprintf(stderr, "error: could not find machine code for assembly:\\n");'
  );
  outLines.push('    std::fprintf(stderr, "  %s\\n", assembly);');
  outLines.push(
    '    std::fprintf(stderr, "Please re-run update-test-asm.mjs to update test-asm-generated.cpp.\\n");'
  );
  outLines.push("    std::terminate();");
  outLines.push("  }");
  outLines.push("  return it->second;");
  outLines.push("}");
  outLines.push("}");
  outLines.push("");
  fs.writeFileSync(outFile, outLines.join("\n"));
}

if (isModuleNodeMain(import.meta)) {
  await mainAsync();
}
